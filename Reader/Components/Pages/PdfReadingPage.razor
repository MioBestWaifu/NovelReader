@layout MainLayout
@page "/pdf-reader"
@using Mio.Reader.Parsing.Loading
@using System.Globalization
@inherits ReadingPage
<FluentDesignTheme Mode=@Configs.Theme CustomColor=@Configs.MainColor></FluentDesignTheme>

@if (Initialized)
{
    <!--Using ternary for conditional classes becasuse so far there are only two reading manners and I dont plan on making others.-->
    <div>

        @{
            base.BuildRenderTree(__builder);
        }
        @{
            PdfChapter chapter = (PdfChapter)Book.TableOfContents[CurrentChapter].Item2;
        }
        @try
        {
            List<PdfNode> lines = chapter.GetLinesForPage(PageIndex);
            <div id="viewer" class="@(Configs.ReadingManner == ReadingManner.Japanese ? "rdr-japanese-viewer" : "rdr-western-viewer")" @onkeydown="HandleKeyPress" @ondblclick="HandleDoubleClick" tabindex="0">
                <!--Not a foreach because the dynamic modifications in loading would break it-->
                @for (int i = 0; i < lines.Count; i++)
                {
                    PdfNode line = lines[i];
                    int currentIndex = i;

                    if (!line.IsImage)
                    {
                        //Uses bottom to position vertically because the origin the PdfRectangle uses is at the bottom left
                        <div style=@($"left:{line.BoundingBox.Left.ToString(CultureInfo.InvariantCulture)}pt;bottom:{(line.BoundingBox.Top - line.BoundingBox.Height).ToString(CultureInfo.InvariantCulture)}pt;width:{line.BoundingBox.Width.ToString(CultureInfo.InvariantCulture)}pt;height:{line.BoundingBox.Height.ToString(CultureInfo.InvariantCulture)}pt") class="@(Configs.ReadingManner == ReadingManner.Japanese? "rdr-japanese-text-block":"rdr-western-text-block")">

                            @for (int j = 0; j < line.TextNodes.Count; j++)
                            {
                                TextNode node = (TextNode)line.TextNodes[j];
                                int currentJ = j;
                                string textToUse = node.Text;
                                if (line.IsFirstNodeShared && currentJ == 0)
                                {
                                    textToUse = textToUse.Substring(line.FirstFrom);
                                }
                                else if (line.IsLastNodeShared && currentJ == line.TextNodes.Count - 1)
                                {
                                    textToUse = textToUse.Substring(0, line.LastUntil + 1);
                                }

                                string id = $"p{i:D3}{j}";
                                <p style="@(plataform == DevicePlatform.Android ? "user-select:none;":"")" class="@(Configs.ReadingManner == ReadingManner.Japanese? "rdr-japanese-text":"rdr-western-text")" id="@id" @onclick="e => HandleClickOnElement(e,id,node)"
                                   @ontouchstart="e => {Task.Run(() => HandleTouchStart(e,id,node));}" @ontouchend="() => touchId++" @onclick:stopPropagation @onmouseup:stopPropagation>@textToUse</p>
                            }
                        </div>
                    }
                    else
                    {
                        ImageNode imageNode = line.ImageNode;
                        <img style=@($"left:{line.BoundingBox.Left.ToString(CultureInfo.InvariantCulture)}pt;bottom:{(line.BoundingBox.Top - line.BoundingBox.Height).ToString(CultureInfo.InvariantCulture)}pt;width:{line.BoundingBox.Width.ToString(CultureInfo.InvariantCulture)}pt;height:{line.BoundingBox.Height.ToString(CultureInfo.InvariantCulture)}pt") src=@($"data:image/{imageNode.Type};base64,{imageNode.Text}") />
                    }
                }
            </div>
        }
        catch (Exception e)
        {

            <p>Error displaying this page:</p>
            <p>@e.Message</p>

            fuckedLines++;
            Debug.WriteLine($"There have been {fuckedLines} fucked lines");
            Debug.WriteLine(e.Message);
            Debug.WriteLine(e.StackTrace);
            if (e.InnerException is not null)
            {
                Debug.WriteLine(e.InnerException);
                Debug.WriteLine(e.InnerException?.StackTrace);
            }
            Debug.WriteLine("----------------------------");
        }
    </div>
}
@code {
    protected override Book? Book
    {
        get
        {
            return base.Book;
        }
        set
        {
            pdf = (Pdf)value;
            base.Book = value;
        }
    }

    private Pdf pdf;

    protected override int CurrentPage {
        get
        {
            return PageIndex + (Book.TableOfContents[CurrentChapter].Item2 as PdfChapter).startPage - 1;
        }
    }

    protected override int PageCount
    {
        //Should be total book pages
        get
        {
            return (pdf.Metadata as PdfMetadata).PageCount;
        }
    }

    private PdfChapter PdfChapter
    {
        get
        {
            return (PdfChapter)Book.TableOfContents[CurrentChapter].Item2;
        }
    }

    protected override async Task LoadChapter(int index, bool firstLoad = false, bool setPageToLast = false)
    {
        Chapter chapter = Book.TableOfContents[index].Item2;
        //To keep track of if the user went to another chapter while the current one was loading
        int thisTaskChapterIndex = CurrentChapter;

        //There needs to be error handling here. Like, a chapter cannot be in loading state forever if something breaks in the loadings. Also, the error needs to be shown and logged.
        if (chapter.LoadStatus == LoadingStatus.Unloaded)
        {
            await bookLoader.BreakChapterToLines(chapter);
            if (firstLoad && interaction.LastTimeNumberOfPages != 0)
            {
                PageIndex = interaction.LastPage;
            }
            else if (setPageToLast)
            {
                //Works because startPage is 1-based
                PageIndex = (chapter as PdfChapter).endPage - (chapter as PdfChapter).startPage;
            }
            else
            {
                PageIndex = 0;
            }

            //Number does not matter but needs assignemnt
            interaction.LastTimeNumberOfPages = 99;

            //For the first loading
            Initialized = true;

            chapter.LoadStatus = LoadingStatus.Loading;

            Progress<int> progressResponder = new Progress<int>(value =>
            {
                InvokeAsync(() =>
            {
                StateHasChanged();
            });
            });
            await bookLoader.ParseChapterContent(chapter, progressResponder);
            int j = 0;
            List<TextNode> allLinesTextNodes = (chapter as PdfChapter).PdfLines.SelectMany(X => X.TextNodes).ToList();
            foreach (TextNode node in allLinesTextNodes)
            {
                Task.Run(() => TranslateFragment(node).ContinueWith(async _ =>
                {
                    chapter.FinishedTextNodes++;
                    InvokeAsync(() =>
                        {
                            StateHasChanged();
                        });
                }));
            }

        }

        else
        {
            if (setPageToLast)
            {
                PageIndex = PdfChapter.endPage - PdfChapter.startPage;
            }
            else
            {
                PageIndex = 0;
            }
            await InvokeAsync(() =>
            {
                StateHasChanged();
            });
        }
    }

    protected override void NextPage()
    {
        if (showPopup)
        {
            ClosePopup();
        }
        if (PageIndex < PdfChapter.endPage - 1)
        {
            PageIndex++;
            interaction.LastPage = PageIndex;
        }
        else
        {
            NextChapter();
        }

        if (Configs.ReadingManner == ReadingManner.Japanese)
            JS.InvokeVoidAsync("scrollToHorizontalStart");
        else
            JS.InvokeVoidAsync("scrollToVerticalStart");
    }

}
