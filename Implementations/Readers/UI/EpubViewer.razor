@using Microsoft.AspNetCore.Components.Forms
@using System.Diagnostics
@using Microsoft.JSInterop
@using System.Xml.Linq

<!--Weird path because this is a library, it is suposed to be used in other projects and this is the way to access files in other projects, it does not get automatically sorted out-->
<script src="_content/Readers/interop.js"></script>

<div id="viewer" style="width:94vw;margin:auto" @onclick="HandleClickOnContent" @onkeydown="HandleKeyPress" tabindex="0">
    @if (Initialized)
    {
        <h1>@Book?.TableOfContents[CurrentChapter].Item1</h1>
        <!--Not a foreach because the dynamic modifications in loading would break it-->
        @for (int i = 0; i < Pages[CurrentPage].Count; i++)
        {
            var line = Pages[CurrentPage][i];
            <!--Images are their own single-node line-->
            @if (line[0] is TextNode)
            {
                <div style="margin-bottom:5px; display:flex; width:100%;flex-wrap:wrap;justify-content:flex-start">
                    @for (int j = 0; j < line.Count; j++)
                    {
                        TextNode node = (TextNode)line[j];
                        string id = $"p{i}{j}";
                        <p id="@id" @onclick="e => ShowPopup(e,id,node.EdrdgEntry)" @onclick:stopPropagation>@node.Text</p>
                    }
                </div>
            }
            else if (line[0] is ImageNode)
            {
                ImageNode imageNode = (ImageNode)line[0];
                <img src=@($"data:image/{imageNode.Type};base64,{imageNode.Text}") style="max-width:100%" />
            }
        }
    }
</div>

@if (showPopup)
{
    <div style="position:fixed;top:0;left:0">
        <TranslationCard Entry="selectedEdrdgEntry" OnClose="ClosePopup" />
    </div>
}
@code {
    [Inject]
    private IJSRuntime JS { get; set; }
    private DotNetObjectReference<EpubViewer> objectReference;

    [Parameter]
    public string PathToFile { get; set; }

    private Epub? Book { get; set; } = null;
    //I sure have a penchant for nested lists. But what can I do? A book IS a list of pages, a page IS a list of lines, and a line IS a list of words. I dont make the rules. Is there some smarter data structure? Probably. But who cares, this is fine.
    private List<List<List<Node>>> Pages { get; set; } = new List<List<List<Node>>>();

    private int CurrentChapter { get; set; } = 0;
    private int CurrentPage { get; set; } = 0;

    private bool Initialized { get; set; } = false;

    private string previousElementId = "";

    private bool showPopup = false;
    private EdrdgEntry selectedEdrdgEntry;

    protected override Task OnInitializedAsync()
    {
        return base.OnInitializedAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        Debug.WriteLine("PathToFile: " + PathToFile);

        Book = await EpubLoader.LoadEpub(PathToFile);
        CurrentChapter = 1;
        Task.Run(async () =>
        {
            //Await the interop file to load
            await Task.Delay(3000);
            //Move thse two things out of here, this will cause problems
            objectReference = DotNetObjectReference.Create(this);
            //await JS.InvokeVoidAsync("resizeHandler.initialize", objectReference);
            await LoadChapter(CurrentChapter);
        });
    }

    private void NextPage()
    {
        if (showPopup)
        {
            ClosePopup();
        }
        if (CurrentPage < Pages.Count - 1)
        {
            CurrentPage++;
        }
        else
        {
            NextChapter();
        }
    }

    private void PreviousPage()
    {
        if (showPopup)
        {
            ClosePopup();
        }
        if (CurrentPage > 0)
        {
            CurrentPage--;
        }
        else
        {
            PreviousChapter();
        }
    }

    private void NextChapter()
    {
        if (CurrentChapter < Book?.TableOfContents.Count - 1)
        {
            CurrentChapter++;
            Task.Run(() => LoadChapter(CurrentChapter));
        }
    }

    private void PreviousChapter()
    {
        if (CurrentChapter > 0)
        {
            CurrentChapter--;
            Task.Run(() => LoadChapter(CurrentChapter));
        }
    }

    private async Task LoadChapter(int index)
    {
        Chapter chapter = Book.TableOfContents[index].Item2;
        CurrentPage = 0;
        //To keep track of if the user went to another chapter while the current one was loading
        int thisTaskChapterIndex = CurrentChapter;
        List<Task> children = new List<Task>();

        if (chapter.LoadStatus == LoadingStatus.Unloaded)
        {
            List<XElement> lines = await EpubFormatter.BreakChapterToLines(chapter);
            Pages = await PreparePages(lines);
            chapter.PrepareLines(lines.Count);
            //For the first loading
            if (!Initialized)
            {
                Initialized = true;
            }
            chapter.LoadStatus = LoadingStatus.Loading;
            for (int i = 0; i < lines.Count; i++)
            {
                int currentIndex = i; // Capture the current index
                children.Add(EpubFormatter.ParseLine(chapter, lines[currentIndex]).ContinueWith(parseLineTask =>
                {
                    Debug.WriteLine("Parsing line " + currentIndex);
                    List<Node> line = parseLineTask.Result;
                    chapter.PushLineToIndex(currentIndex, line);
                    if (thisTaskChapterIndex == CurrentChapter)
                    {
                        PushLineToPages(currentIndex, line);
                        InvokeAsync(() =>
                        {
                            StateHasChanged();
                        });
                    }
                }));
            }

            Task.WhenAll(children).ContinueWith(t =>
            {
                chapter.LoadStatus = LoadingStatus.Loaded;
            });
        }

        else
        {
            Pages = await BreakChapterToPages(chapter);
            InvokeAsync(() =>
            {
                StateHasChanged();
            });
        }
    }

    private void PushLineToPages(int index, List<Node> line)
    {
        int linesPerPage = Pages[CurrentPage].Count;
        int pageIndex = Math.DivRem(index, linesPerPage, out int lineIndex);
        Pages[pageIndex][lineIndex] = line;
    }

    private async Task<List<List<List<Node>>>> PreparePages(List<XElement> lines)
    {

        int lineHeight = 30;
        int windowHeight = await JS.InvokeAsync<int>("getWindowHeight");
        int linesPerPage = windowHeight / lineHeight;

        List<List<List<Node>>> pages = new List<List<List<Node>>>();

        int totalLines = lines.Count;
        int totalPages = (totalLines + linesPerPage - 1) / linesPerPage; // Calculate total pages

        for (int i = 0; i < totalPages; i++)
        {
            List<List<Node>> page = new List<List<Node>>(linesPerPage); // Create a new page with linesPerPage lines
            for (int j = 0; j < linesPerPage; j++)
            {
                page.Add([new Node() { }]); // Add an empty line to the page
            }
            pages.Add(page); // Add the page to the pages
        }

        return pages;
    }


    private async Task<List<List<List<Node>>>> BreakChapterToPages(Chapter chapter)
    {
        //Value out of my ass, replace with something actual based on the used css + margins
        int lineHeight = 30;
        int windowHeight = await JS.InvokeAsync<int>("getWindowHeight");
        int linesPerPage = windowHeight / lineHeight;

        List<List<List<Node>>> pages = [];
        List<List<Node>> currentPage = [];
        foreach (List<Node> line in chapter.Lines)
        {
            currentPage.Add(line);

            if (currentPage.Count == linesPerPage)
            {
                pages.Add(currentPage);
                currentPage = new List<List<Node>>();
            }
        }

        // Add the last page if it has any lines
        if (currentPage.Count > 0)
        {
            pages.Add(currentPage);
        }

        return pages;
    }

    private async void ShowPopup(MouseEventArgs e, string id ,EdrdgEntry edrdgEntry)
    {
        //Necessary because not everything has a translation for various reasons
        if (edrdgEntry is null)
        {
            return;
        }
        selectedEdrdgEntry = edrdgEntry;
        if (showPopup)
        {
            await RemovePreviousElementBackgroundColor();
        }
        showPopup = true;
        await JS.InvokeVoidAsync("setElementBackgroundColor", id, "#d3d3d3");
        previousElementId = id;
    }

    private async void HandleClickOnContent(MouseEventArgs e)
    {
        if (showPopup)
        {
            ClosePopup();
            return;
        }

        int windowWidth = await JS.InvokeAsync<int>("getWindowHeight");

        if (e.ClientX < windowWidth / 2)
        {
            PreviousPage();
        }
        else
        {
            NextPage();
        }
        //Does not work without this call. Shouldn't Blazor be able to detect changes and re-render automatically?
        StateHasChanged();
    }

    private async Task RemovePreviousElementBackgroundColor()
    {
        await JS.InvokeVoidAsync("removeElementBackgroundColor", previousElementId);
        previousElementId = "";
    }

    private void HandleKeyPress(KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "Escape":
                if (showPopup)
                    ClosePopup();
                break;
            case "ArrowLeft":
                PreviousPage();
                break;
            case "ArrowRight":
                NextPage();
                break;
        }
        //Does not work without this call. Shouldn't Blazor be able to detect changes and re-render automatically?
        StateHasChanged();
    }

    /*[JSInvokable]
    public async Task OnResize()
    {
        //Forcing the popup to close because of how the element selection works, it breaks if the position changes
        if (showPopup)
        {
            ClosePopup();
            StateHasChanged();
        }
    }*/

    private async void ClosePopup()
    {
        showPopup = false;
        selectedEdrdgEntry = null;
        await RemovePreviousElementBackgroundColor();
    }

}
